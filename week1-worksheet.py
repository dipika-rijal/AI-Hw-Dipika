# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gBSyV806E64LTMvCsAEfdsj6IP5N0Jni
"""



import numpy as np
import random
from timeit import timeit

# Define addition functions
def add_python(Z1, Z2):
    return [z1 + z2 for z1, z2 in zip(Z1, Z2)]

def add_numpy(Z1, Z2):
    return np.add(Z1, Z2)

# Generate larger random sample data
size = 100000  # Increased size for more pronounced difference
Z1_list = random.sample(range(size + 1), size)
Z2_list = random.sample(range(size + 1), size)
Z1_np = np.array(Z1_list)
Z2_np = np.array(Z2_list)

# Time the execution of each function
python_time = timeit("add_python(Z1_list, Z2_list)", globals=globals(), number=100)
numpy_time = timeit("add_numpy(Z1_np, Z2_np)", globals=globals(), number=100)

# Print results
print(f"Pure Python addition: {python_time:.6f} seconds per loop")
print(f"NumPy addition: {numpy_time:.6f} seconds per loop")

import numpy as np
import random
from timeit import timeit
# Define addition functions
def add_python(Z1, Z2) :
    return [z1 + z2 for z1, z2 in zip(Z1, Z2)]
def add_numpy (Z1, Z2) :
    return np. add (Z1, Z2)
# Generate random sample data
Z1 = random. sample (range(1000), 100)
Z2 = random. sample (range (1000), 100)
# Time the execution of each function
python_time = timeit("add_python(Z1, Z2)", globals=globals(), number=1000)
numpy_time = timeit("add_numpy(Z1, Z2)", globals=globals(), number=10000)
# Print results
print(f"Pure Python addition: {python_time:.2f} s per loop")
print(f"NumPy addition: {numpy_time: .2f} s per loop")

import numpy as  Dipika



import numpy as np

# initialize an all zero array with size 2 X 3:
zeros_arr = np.zeros((2, 3))
print("A zeros array is\n", zeros_arr, "with dimensions", zeros_arr.shape, "\n")

import numpy as np

# Create and display zero, one, and n-dimensional arrays
zero_dim_array = np.array(5)
one_dim_array = np.array([1, 2, 3])
n_dim_array = np.array([[1, 2], [3, 4]])
for arr in [zero_dim_array, one_dim_array, n_dim_array]:
    print(f"Array:\n{arr}\nDimension: {arr.ndim}\nData type: {arr.dtype}\n")

# Code implementation:

import numpy as np
# Create arrays of different dimensions
array_0d = np.array(5)
array_1d = np.array([1, 2, 3, 4, 5])
array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

# Print arrays with shapes
for i, arr in enumerate([array_0d, array_1d, array_2d, array_3d]):
    print(f"{i}D Array:\n{arr}\nShape: {arr.shape}\n")

import numpy as np
array = np.array([[1, 2, 3], [4, 5, 6]]) # Shape (2, 3)
reshaped_array = array.reshape(3, 2) # Reshape to (3, 2), keeping 6 elements
print("Original Shape:", array.shape, "\nReshaped Shape: ", reshaped_array.shape)

import numpy as np
a = np.arange(1, 10)
print(a)
x = range(1, 10)
print(x)    # x is an iterator
print(list(x))
# further orange examples:
x = np.arange(10.4)
print(x)
x = np.arange(0.5, 10.4, 0.8)
print(x)

import numpy as np
# 50 values between 1 and 10:
print(np.linspace(1, 10))
# 7 values between 1 and 10:
print(np.linspace(1, 10, 7))
# excluding the endpoint:
print(np.linspace(1, 10, 7, endpoint=False))

import numpy as np
# Create arrays of specified shapes
ones_array = np.ones((2, 3))    # Shape: (2, 3)
zeros_array = np.zeros((3, 2))    # Shape: (3, 2)
empty_array = np.empty((2, 2))    # Shape: (2, 2)
identity_matrix = np.eye(3)    # Shape: (3, 3)
print(ones_array, zeros_array, empty_array,
    identity_matrix, sep='\n\n')

import numpy as np
array_from_list = np.array([1, 2, 3]) # [1 2 3]
array_from_tuple = np.array((4, 5, 6)) # [4 5 6]
array_from_nested_list = np.array([[1, 2, 3], [4, 5, 6]]) # [[1 2 3] [4 5 6]]
print(array_from_list, array_from_tuple,
    array_from_nested_list, sep='\n')

import numpy as np
# Existing Array of Shape:(2,3)
arr = np.array([[1, 2, 3], [4, 5, 6]])
# Creating Array with Shape of existing array:
zeros, ones, empty = np.zeros(arr.shape), np.ones( arr.shape), np.empty(arr.shape) # Shape: (2,3)
print(arr, zeros, ones, empty, sep='\n')

import numpy as np
array = np.array([1, 2, 3])
# Multiplies each element by 2, result: [2, 4, 6]
new_array = array * 2
# Creates a new array with the same elements
copied_array = np.copy(array)
# Slices elements from index 1 to 3, result:[2]
sliced_array = array[1:2]

import numpy as np
arr1 = np.array([[1, 2], [3, 4]])    # Shape: (2, 2)
arr2 = np.array([[5, 6], [7, 8]])    # Shape: (2, 2)
# Stacking examples
hstacked = np.hstack((arr1, arr2))
# Output hstack: [[1 2 5 6] [3 4 7 8]]
vstacked = np.vstack((arr1, arr2))
# Output vstack[[1 2] [3 4] [5 6] [7 8]]
colstacked = np.column_stack((arr1[0], arr2[0]))
# Output column stack: [[1 5] [2 6]]
print(hstacked, vstacked, colstacked, sep='\n')

import numpy as np
arr1 = np.array([[1, 2], [3, 4]]) # Shape: (2, 2)
arr2 = np.array([[5, 6], [7, 8]]) # Shape: (2, 2)
concat_axis0 = np.concatenate((arr1, arr2), axis=0)
# Concatenate along axis 0 (vertical) Shape: (4, 2)
concat_axis1 = np.concatenate((arr1, arr2), axis=1)
# Concatenate along axis 1 (horizontal) Shape: (2, 4)
print(concat_axis0, concat_axis1, sep='\n')

#slicing
import numpy as np
# Arrays
arr1d = np.array([0, 1, 2, 3, 4, 5])
arr2d = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
arr3d = np.array([[[0, 1], [2, 3]], [[4, 5], [6, 7]], [[8, 9], [10, 11]]])

# Slicing examples
print("Basic:", arr1d[1:4], arr2d[1:3, 0:2], arr3d[1:2, 0:2, 1:2])

# Output Basic: arr1d:[1 2 3] arr2d:[[3 4] [6 7]] arr3d :[[[5] [7]]]

print("Step:", arr1d[1:5:2], arr2d[:2, 1::2], arr3d[::2, ::2, 1::2])

import numpy as np
# Define two matrices
A = np.array([[1, 2, 3], [4, 5, 6]])
B = np.array([[7, 8], [9, 10], [11, 12]])
# Matrix multiplication using np.dot
result_dot = np.dot(A, B)
print("Result with np.dot:\n", result_dot)

import numpy as np
# Define two matrices
A = np.array([[1, 2, 3], [4, 5, 6]])
B = np.array([[7, 8], [9, 10], [11, 12]])
# Matrix multiplication using @ operator
result_at = A @ B
print("Result with @ operator:\n", result_at) # Output shape: (2, 2)
# Matrix multiplication using np.matmul
result_matmul = np.matmul(A, B)
print("Result with np.matmul:\n", result_matmul) # Output shape: (2, 2)

import numpy as np
A = np.array([[1, 2], [3, 4]])
B = np.array([5, 6])
print("Inverse:\n", np.linalg.inv(A))
# Output: Inverse: [[-2.  1. ], [ 1.5 -0.5]]
print("Determinant:", np.linalg.det(A))
# Output: Determinant: -2.0
print("Frobenius Norm:", np.linalg.norm(A, 'fro'))
# Output: Frobenius Norm: 5.4772
print("2-Norm (Euclidean):", np.linalg.norm(A))
# Output: 2-Norm(Euclidean): 5.4772
print("Solution x:", np.linalg.solve(A, B))
#Output: Solution x: [-4.  4.5]

